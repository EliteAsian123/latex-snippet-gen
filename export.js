function exportSty() {
  let file = `\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This file was generated by the LaTeX Snippet Generator %
%   https://eliteasian123.github.io/latex-snippet-gen/   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\usepackage{xparse}
\\usepackage{amsmath}
`;

  let packageSection = "";
  let commandSection = "";

  let disabledCommands = [];
  for (const selectionId in selectionState) {
    if (selectionState[selectionId].selected && selectionId in PACKAGES) {
      const package = PACKAGES[selectionId];

      packageSection += package.definition + "\n";

      for (const cmd of package.disableCommands) {
        disabledCommands.push(cmd);
      }
    }
  }

  for (const selectionId in selectionState) {
    const selection = selectionState[selectionId];

    if (selection.selected && selectionId in COMMANDS) {
      if (disabledCommands.indexOf(selectionId) != -1) {
        continue;
      }

      const command = COMMANDS[selectionId];
      let parsedDef = command.definition.replaceAll("@", selection.name);

      commandSection += parsedDef + "\n";
    }
  }

  file += packageSection;
  file += "\n";
  file += commandSection;

  let blob = new Blob([file], { type: "text/plain;charset=utf-8" });
  saveAs(blob, "cmd.sty");
}

function expandPref(prefs, atWord) {
  const split = atWord.split(";");
  const name = split[0];

  if (!(name in prefs)) {
    console.error(`Unknown pref ${name}. Returning nothing.`);
    return "";
  }

  const pref = prefs[name];
  if (pref.type === "insert") {
    if (split.length > 1) {
      console.warn(`Too many arguments on ${name}.`);
    }

    return pref.value;
  } else if (pref.type === "wrap") {
    if (split.length < 2) {
      console.error(`Not enough arguments on ${name}. Returning nothing.`);
      return "";
    }

    if (split.length > 2) {
      console.warn(`Too many arguments on ${name}.`);
    }

    return pref.value.replaceAll("@", split[1]);
  } else if (pref.type === "command") {
    let value = pref.value;
    for (let i = 1; i < split.length; i++) {
      value = value.replaceAll(`@${i}@`, split[i]);
    }
    return value;
  }
}

function parseDefinition(prefs, definition) {
  let parsedDef = "";
  let atWord = "";
  let atMode = false;
  for (const c of definition) {
    if (!atMode) {
      if (c === "@") {
        atMode = true;
      } else {
        parsedDef += c;
      }
    } else {
      if (c === "@") {
        atMode = false;
        parsedDef += expandPref(prefs, atWord);
        atWord = "";
      } else {
        atWord += c;
      }
    }
  }

  if (atMode) {
    console.error("Unclosed at!");
    return undefined;
  }

  return parsedDef;
}

function exportVscodeSnippets() {
  const prefs = getPrefs();
  let data = {};

  for (const selectionId in selectionState) {
    const selection = selectionState[selectionId];

    if (selection.selected && selectionId in SNIPPETS) {
      const snippet = SNIPPETS[selectionId];

      const parsedDef = parseDefinition(prefs, snippet.definition);
      if (parsedDef === undefined) {
        continue;
      }

      data[snippet.title] = {
        prefix: selection.name,
        description: snippet.description,
        body: parsedDef.split("\n")
      };
    }
  }

  let blob = new Blob([JSON.stringify(data, null, 2)], { type: "text/plain;charset=utf-8" });
  saveAs(blob, "latex.json");
}
