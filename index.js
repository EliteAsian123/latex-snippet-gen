const selectionsParent = document.getElementById("selections");
let selectionState;

reset();
populateSelections();

function selectCommand(commandId, command) {
  selectionState[commandId] = {
    name: command.defaultName
  };
}

function reset() {
  selectionState = {};

  for (const packageId in PACKAGES) {
    const package = PACKAGES[packageId];

    if (package.defaultSelect) {
      selectionState[packageId] = {};
    }
  }

  for (const commandId in COMMANDS) {
    const command = COMMANDS[commandId];

    if (command.defaultSelect) {
      selectCommand(commandId, command);
    }
  }
}

function populateSelections() {
  selectionsParent.innerHTML = "";

  const disabledPackages = [];
  const disabledCommands = [];

  // Look at disabled packages and commands
  for (const packageId in PACKAGES) {
    if (packageId in selectionState && disabledPackages.indexOf(packageId) == -1) {
      const packageInfo = PACKAGES[packageId];

      for (const package of packageInfo.disablePackages) {
        disabledPackages.push(package);
      }

      for (const command of packageInfo.disableCommands) {
        disabledCommands.push(command);
      }
    }
  }

  const packagesTitle = getTemplate("selectionTitle");
  packagesTitle.querySelector(".label").replaceChildren(
    new Text("LaTeX Package Preferences"));
  packagesTitle.querySelector(".info").replaceChildren(
    new Text(`(${Object.keys(PACKAGES).length})`));
  selectionsParent.append(packagesTitle);

  for (const packageId in PACKAGES) {
    const package = PACKAGES[packageId];
    const template = getTemplate("selectionCheckbox");
    const disabled = disabledPackages.indexOf(packageId) != -1;

    // Update label text
    const label = template.querySelector(".label");
    label.replaceChildren(new Text(package.title));
    if (disabled) {
      label.classList.add("disabled");
    }

    // Update checkbox properties
    const checkbox = template.querySelector("input");
    checkbox.checked = packageId in selectionState;
    if (!disabled) {
      checkbox.addEventListener("change", function() {
        if (this.checked) {
          selectionState[packageId] = {};
        } else {
          delete selectionState[packageId];
        }
        populateSelections();
      });
    } else {
      checkbox.disabled = true;
    }

    selectionsParent.append(template);
  }

  const commandsTitle = getTemplate("selectionTitle");
  commandsTitle.querySelector(".label").replaceChildren(
    new Text("LaTeX Commands"));
  commandsTitle.querySelector(".info").replaceChildren(
    new Text(`(${Object.keys(COMMANDS).length})`));
  selectionsParent.append(commandsTitle);

  for (const commandId in COMMANDS) {
    const command = COMMANDS[commandId];
    const template = getTemplate("selectionCheckbox");
    const disabled = disabledCommands.indexOf(commandId) != -1;

    // Update label text
    const label = template.querySelector(".label");
    label.replaceChildren(new Text(command.title));
    if (disabled) {
      label.classList.add("disabled");
    }

    // Update checkbox properties
    const checkbox = template.querySelector("input");
    checkbox.checked = commandId in selectionState;
    if (!disabled) {
      checkbox.addEventListener("change", function() {
        if (this.checked) {
          selectCommand(commandId, command);
        } else {
          delete selectionState[commandId];
        }
      });
    } else {
      checkbox.disabled = true;
    }

    selectionsParent.append(template);
  }
}

function getTemplate(templateId) {
  const template = document.getElementById(templateId);
  if (!(template instanceof HTMLTemplateElement)) {
    throw new Error(`${templateId} does not exist in the DOM`);
  }

  const container = template.content.firstElementChild?.cloneNode(true);
  if (!(container instanceof HTMLElement)) {
    throw new Error(`${templateId} container is not an HTML element`);
  }

  return container;
}

function exportSty() {
  let file = `\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This file was generated by the LaTeX Snippet Generator %
%   https://eliteasian123.github.io/latex-snippet-gen/   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\\usepackage{xparse}
\\usepackage{amsmath}
`;

  let packageSection = "";
  let commandSection = "";

  let disabledCommands = [];
  for (const selectionId in selectionState) {
    if (selectionId in PACKAGES) {
      const package = PACKAGES[selectionId];

      packageSection += package.definition + "\n";

      for (const cmd of package.disableCommands) {
        disabledCommands.push(cmd);
      }
    }
  }

  for (const selectionId in selectionState) {
    const selection = selectionState[selectionId];

    if (selectionId in COMMANDS) {
      if (disabledCommands.indexOf(selectionId) != -1) {
        continue;
      }

      const command = COMMANDS[selectionId];

      let parsedDef = "";
      let atWord = "";
      let atMode = false;
      for (const c of command.definition) {
        if (!atMode) {
          if (c === "@") {
            atMode = true;
          } else {
            parsedDef += c;
          }
        } else {
          if (c === "@") {
            atMode = false;

            if (atWord === "_name") {
              parsedDef += "\\" + selection.name;
            } else {
              console.warn("Unknown at. Inserting nothing.");
            }

            atWord = "";
          } else {
            atWord += c;
          }
        }
      }

      if (atMode) {
        console.error("Unclosed at!");
        continue;
      }

      commandSection += parsedDef + "\n";
    }
  }

  file += packageSection;
  file += "\n";
  file += commandSection;

  let blob = new Blob([file], { type: "text/plain;charset=utf-8" });
  saveAs(blob, "cmd.sty");
}
